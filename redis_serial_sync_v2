#!/usr/bin/env python3

# export keys between 2 redis DB with serial port
#
# redis A    <--- /dev/ttyAMA0 ---> redis B
#
# set tx:k1   --------------------> rx:k1
# rx:k2      <--------------------  set tx:k2


import argparse
import atexit
import json
import redis
import serial
import threading
import time


# parse argument
parser = argparse.ArgumentParser(description='Redis bridge over serial link')
parser.add_argument('-n', '--name', type=str, default='rem',
                    help='Bridge name (default is rem)')
parser.add_argument('-d', '--device', type=str, default='/dev/ttyAMA0',
                    help='Serial device (default is /dev/ttyAMA0)')
parser.add_argument('-b', '--baud', type=int, default=460800,
                    help='Baud rate (default is 460800)')
parser.add_argument('--alive', type=float, default=5.0,
                    help='Alive interval in second (default is 5.0)')
args = parser.parse_args()


# some var
r = redis.StrictRedis(db=0)
# s = serial.serial_for_url('loop://', baudrate=115200)
s = serial.Serial(args.device, baudrate=args.baud)


# compute a check sum (XOR of bytes)
def get_c_sum(msg):
    c_sum = 0
    for i in msg:
        c_sum ^= i
    return c_sum


def rx_dict_as_json():
    # read message:  [RAW message: json + checksum]\n
    msg = s.readline().rstrip()
    # decode message parts: [json part][hex checksum]
    msg_sum = msg[-2:]
    msg_json = msg[:-2]
    # check sum part
    try:
        rx_sum = int(msg_sum, base=16)
        js_sum = get_c_sum(msg_json)
        if rx_sum != js_sum:
            raise ValueError
    except ValueError:
        r.incr('bridge:rx_sum_error_counter')
        print('rx error : check sum mismatch !!!')
        return None
    r.incr('bridge:rx_frame_counter')
    # DEBUG
    print('calc_sum:%i rx_sum:%i raw_len:%i raw_msg:%s' % (get_c_sum(msg_json),  int(msg_sum, base=16), len(msg), msg))
    # decode json part
    return json.loads(msg_json.decode('utf8'))


def tx_dict_as_json(d):
    js_msg = json.dumps(d, separators=(',', ':')).encode('utf8')
    s.write(js_msg + b'%02X\n' % get_c_sum(js_msg))
    r.incr('bridge:tx_frame_counter')


# ensure clean at exit
@atexit.register
def clean_exit():
    s.close()


# create local redis key "rx:key_name" on serial receive
def read_thread():
    while True:
        # receive json part
        js_d = rx_dict_as_json()
        if js_d:
            msg_type = js_d['t']
            # process every message type
            if msg_type == 'alive':
                remote = js_d['n']
                print('rx alive message from %s' % remote)
            elif msg_type == 'rpub':
                print('rx pubsub message')
                chan = 'rx:' + js_d['c']
                msg = js_d['m']
                r.publish(chan, msg)
            elif msg_type == 'rkey':
                print('it\'s a Redis Key Exchange message')
                k = 'rx:' + js_d['k']
                v = js_d['v']
                r.set(k, v)


# export local tx:key_name to serial port and remove it
def write_thread():
    # init thread vars
    t_tx_alive = 0.0
    # redis pubsub: subscribe to all tx:* channels
    p = r.pubsub()
    p.psubscribe('tx:*')
    # main loop
    while True:
        # send alive message (at startup and every 5s)
        if time.time() - t_tx_alive > args.alive:
            tx_dict_as_json({'t': 'alive', 'n': args.name})
            t_tx_alive = time.time()
        # check pubsub message
        while True:
            d_msg = p.get_message()
            if d_msg is None:
                break
            elif d_msg['type'] == 'pmessage':
                print('pubsub', d_msg['channel'], d_msg['data'])
                chan = d_msg['channel'].decode('utf8')[3:]
                msg = d_msg['data'].decode('utf8')
                tx_dict_as_json({'t': 'rpub', 'c': chan, 'm': msg})
        # search all tx:key_name redis keys and send it
        for key in r.keys('tx:*'):
            # format compact json msg
            k = key.decode('utf8')[3:]
            v = r.get(key).decode('utf8')
            tx_dict_as_json({'t': 'rkey', 'k': k, 'v': v})
            r.delete(key)
        # before next loop
        time.sleep(0.2)

# init bridge status
r.set('bridge:name', args.name)
r.set('bridge:tx_frame_counter', 0)
r.set('bridge:rx_frame_counter', 0)
r.set('bridge:rx_sum_error_counter', 0)

# start serial IO thread
threading.Thread(target=read_thread).start()
threading.Thread(target=write_thread).start()
