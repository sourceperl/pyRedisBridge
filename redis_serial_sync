#!/usr/bin/env python3

"""Export keys/publish between 2 redis DB with serial port."""

#  node A              <- /dev/ttyUSB0 ->   node B
#  remote = ndb                             remote = nda
#
# key exchange with remote:
#  set tx:ndb:key1      ---------------->   rx:nda:key1
#  rx:ndb:key2         <----------------    set tx:nda:key2
#
# publish to/from remote:
#  publish tx:ndb:chan1  --------------->   rx:nda:chan1
#  rx:ndb:chan2         <---------------    publish tx:nda:chan2


import argparse
import atexit
import logging
import json
import sys
import signal
import threading
import time
import redis
import serial


# some functions
def msg_checksum(msg):
    """Compute a check sum (XOR of bytes)."""
    c_sum = 0
    for i in msg:
        c_sum ^= i
    return c_sum


# threads define
def import_thread():
    """Thread that process income serial message.
    Produce redis rx:rem:key for remote key or rx:rem:channel
    for remote publish on incoming ad-hoc message.
    Update stats for alive message.
    """
    # flush serial buffer
    ser.flushInput()
    # receive loop
    while True:
        # read message:  [dict as a compact json msg][C-SUM]CR
        serial_msg = ser.readline()
        # decode message parts: [json part][2 digits hex checksum]
        clean_msg = serial_msg.rstrip()
        checksum_part = clean_msg[-2:]
        json_part = clean_msg[:-2]
        # check sum part
        try:
            if int(checksum_part, base=16) != msg_checksum(json_part):
                raise ValueError
        except ValueError:
            rdb.hincrby(stats_hash, stat_checksum_err)
            logging.warning('receive frame with check sum error')
            continue
        # decode json part
        try:
            json_d = json.loads(json_part.decode('utf8'))
        except (ValueError, UnicodeDecodeError):
            rdb.hincrby(stats_hash, stat_format_err)
            logging.warning('receive frame with format error')
            continue
        # dump rx frame
        logging.debug('receive frame [len:%i raw_msg:%s]' % (len(serial_msg), serial_msg))
        # process every message type
        try:
            # alive frame
            if json_d['type'] == 'alive':
                rdb.hset(stats_hash, stat_since_alive, 0)
                logging.debug('receive an alive message from remote')
            # redis publish frame
            elif json_d['type'] == 'rpub':
                chan = rx_prefix + json_d['chan']
                clean_msg = json_d['msg']
                rdb.publish(chan, clean_msg)
                rdb.hincrby(stats_hash, stat_rx_count)
                logging.debug('receive a publish from remote (channel="%s", message="%s")' % (chan, clean_msg))
            # redis key frame
            elif json_d['type'] == 'rkey':
                remote_k = rx_prefix + json_d['key']
                remote_v = json_d['val']
                rdb.set(remote_k, remote_v)
                rdb.hincrby(stats_hash, stat_rx_count)
                logging.debug('receive a key from remote (key="%s", value="%s")' % (remote_k, remote_v))
        except KeyError as k_except:
            logging.debug('field %s not found in json message' % k_except)


def export_thread():
    """Thread that export redis key as tx:[remote]:my_key to serial port"""

    def tx_as_json(d):
        """Convert dict object to [dict as compact json msg][C-SUM]CR and send-it."""
        # dict -> compact json msg as bytes
        js_msg = json.dumps(d, separators=(',', ':')).encode('utf8')
        # add check sum as hex string to json msg, end with a CR
        c_sum = '%02X\n' % msg_checksum(js_msg)
        raw_msg = js_msg + c_sum.encode('utf8')
        # send RAW message to serial line
        ser.write(raw_msg)
        # dump tx frame
        logging.debug('transmit frame [raw_len:%i raw_msg:%s]' % (len(raw_msg), raw_msg))

    # init thread vars
    t_tx_alive = 0.0
    # redis pubsub: subscribe to all tx:[remote]:* channels
    p = rdb.pubsub()
    p.psubscribe(tx_prefix + '*')
    len_pfx = len(tx_prefix)
    # main loop
    while True:
        # send alive message (at startup and every args.alive seconds)
        if time.time() - t_tx_alive > args.alive:
            tx_as_json({'type': 'alive'})
            t_tx_alive = time.time()
        # check pubsub message
        while True:
            d_msg = p.get_message()
            if d_msg is None:
                break
            elif d_msg['type'] == 'pmessage':
                try:
                    tx_chan = d_msg['channel'].decode('utf8')[len_pfx:]
                    tx_msg = d_msg['data'].decode('utf8')
                    tx_as_json({'type': 'rpub', 'chan': tx_chan, 'msg': tx_msg})
                    rdb.hincrby(stats_hash, stat_tx_count)
                except UnicodeDecodeError:
                    logging.warning('transmit redis publish contain non-utf8 byte, skip it')
        # search all tx:key_name redis keys and send it
        for key in rdb.keys(tx_prefix + '*'):
            try:
                tx_key = key.decode('utf8')[len_pfx:]
                tx_value = rdb.get(key).decode('utf8')
                tx_as_json({'type': 'rkey', 'key': tx_key, 'val': tx_value})
                rdb.hincrby(stats_hash, stat_tx_count)
            except UnicodeDecodeError:
                logging.debug('transmit redis key contain non-utf8 byte, skip it')
            rdb.delete(key)
        # before next loop
        time.sleep(0.2)


if __name__ == '__main__':
    # parse argument
    parser = argparse.ArgumentParser(description='Redis bridge over serial link')
    parser.add_argument('-p', '--port', type=str, default='/dev/ttyAMA0',
                        help='serial port (default is /dev/ttyAMA0)')
    parser.add_argument('-b', '--baud', type=int, default=115200,
                        help='baud rate (default is 115200)')
    parser.add_argument('-d', '--debug', action='store_true',
                        help='set debug mode')
    parser.add_argument('-r', '--remote', type=str, default='rem',
                        help='name of the remote bridge instance (default is "rem")')
    parser.add_argument('--alive', type=float, default=30.0,
                        help='alive interval in second (default is 30.0)')
    parser.add_argument('--db', type=int, default=0,
                        help='redis DB number to connect (default is 0)')
    args = parser.parse_args()

    # set signal handler
    signal.signal(signal.SIGTERM, lambda sig_num, frame: sys.exit)

    # set logging
    if args.debug:
        logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
    else:
        logging.basicConfig(stream=sys.stderr)

    # log startup
    logging.debug('redis_serial_sync start')

    # handle DB or serial excepts
    try:
        # init Redis DB
        rdb = redis.StrictRedis(db=args.db)
        # init serial port
        ser = serial.Serial(args.port, baudrate=args.baud)

        # set tx/rx prefix
        tx_prefix = f'tx:{args.remote}:'
        rx_prefix = f'rx:{args.remote}:'

        # init bridge hash status
        stats_hash = f'brg:{args.remote}:stats'
        stat_port = 'port'
        stat_redis_db = 'redis_db'
        stat_since_alive = 'since_alive'
        stat_checksum_err = 'checksum_error'
        stat_format_err = 'format_error'
        stat_tx_count = 'tx_count'
        stat_rx_count = 'rx_count'
        # clear old hash and populate-it with initial values
        rdb.delete(stats_hash)
        rdb.hset(stats_hash, stat_port, args.port)
        rdb.hset(stats_hash, stat_redis_db, args.db)
        rdb.hset(stats_hash, stat_since_alive, 0)
        rdb.hset(stats_hash, stat_checksum_err, 0)
        rdb.hset(stats_hash, stat_format_err, 0)
        rdb.hset(stats_hash, stat_tx_count, 0)
        rdb.hset(stats_hash, stat_rx_count, 0)

        # at exit handler
        def on_exit():
            """Exit handler."""
            # remove all owned redis keys
            for k in rdb.keys(rx_prefix + '*'):
                rdb.delete(k)
            # remove stats hash
            rdb.delete(stats_hash)
            # close serial port
            ser.close()
        # register on_exit handler
        atexit.register(on_exit)

        # start serial IO thread
        threading.Thread(target=import_thread, daemon=True).start()
        threading.Thread(target=export_thread, daemon=True).start()

        # main thread
        while True:
            rdb.hincrby(stats_hash, stat_since_alive)
            time.sleep(1.0)

    # on redis error
    except redis.RedisError as e:
        logging.error('redis error (%s)' % e)
        exit(1)

    # on serial error
    except serial.SerialException as e:
        logging.error('serial port error (%s)' % e)
        exit(1)
