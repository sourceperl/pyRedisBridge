#!/usr/bin/env python3
# coding: utf8

# export keys between 2 redis DB with serial port
#
# redis A    <--- /dev/ttyAMA0 ---> redis B
#
# set tx:k1   --------------------> rx:k1
# rx:k2      <--------------------  set tx:k2


import argparse
import atexit
import json
import redis
import serial
import threading
import time


# some functions
# compute a check sum (XOR of bytes)
def get_c_sum(msg):
    c_sum = 0
    for i in msg:
        c_sum ^= i
    return c_sum


def rx_dict_as_json():
    # read message:  [RAW message: json + checksum]\n
    msg = s.readline().rstrip()
    # decode message parts: [json part][hex checksum]
    msg_sum = msg[-2:]
    msg_json = msg[:-2]
    # check sum part
    try:
        rx_sum = int(msg_sum, base=16)
        js_sum = get_c_sum(msg_json)
        if rx_sum != js_sum:
            raise ValueError
    except ValueError:
        r.incr(r_name + 'rx_sum_error_counter')
        print('rx error : check sum mismatch !!!')
        return None
    # update status
    r.incr(r_name + 'rx_frame_counter')
    # DEBUG rx message
    print('calc_sum:%i rx_sum:%i raw_len:%i raw_msg:%s' % (get_c_sum(msg_json), int(msg_sum, base=16), len(msg), msg))
    # decode json part
    try:
        rx_dict = json.loads(msg_json.decode('utf8'))
    except (json.decoder.JSONDecodeError, UnicodeDecodeError):
        r.incr(r_name + 'rx_format_error_counter')
        print('rx error : format error !!!')
        return None
    return rx_dict


def tx_dict_as_json(d):
    js_msg = json.dumps(d, separators=(',', ':')).encode('utf8')
    s.write(js_msg + b'%02X\n' % get_c_sum(js_msg))
    r.incr(r_name + 'tx_frame_counter')


# ensure clean at exit
@atexit.register
def clean_exit():
    # remove redis status key
    r.delete(r_name + 'device')
    r.delete(r_name + 'redis_db')
    r.delete(r_name + 'tx_frame_counter')
    r.delete(r_name + 'rx_frame_counter')
    r.delete(r_name + 'rx_sum_error_counter')
    r.delete(r_name + 'rx_format_error_counter')
    # close serial port
    s.close()


# read/write threads
# create local redis key "rx:key_name" on serial receive
def read_thread():
    while True:
        # receive json part
        js_d = rx_dict_as_json()
        if js_d:
            msg_type = js_d['t']
            # process every message type
            if msg_type == 'alive':
                remote = js_d['n']
                print('rx alive message from %s' % remote)
            elif msg_type == 'rpub':
                chan = 'rx:' + js_d['c']
                msg = js_d['m']
                r.publish(chan, msg)
                print('rx pubsub message')
            elif msg_type == 'rkey':
                k = 'rx:' + js_d['k']
                v = js_d['v']
                r.set(k, v)
                print('rx remote key')


# export local tx:key_name to serial port and remove it
def write_thread():
    # init thread vars
    t_tx_alive = 0.0
    # redis pubsub: subscribe to all tx:* channels
    p = r.pubsub()
    p.psubscribe('tx:*')
    # main loop
    while True:
        # send alive message (at startup and every 5s)
        if time.time() - t_tx_alive > args.alive:
            tx_dict_as_json({'t': 'alive', 'n': args.name})
            t_tx_alive = time.time()
        # check pubsub message
        while True:
            d_msg = p.get_message()
            if d_msg is None:
                break
            elif d_msg['type'] == 'pmessage':
                chan = d_msg['channel'].decode('utf8')[3:]
                msg = d_msg['data'].decode('utf8')
                tx_dict_as_json({'t': 'rpub', 'c': chan, 'm': msg})
        # search all tx:key_name redis keys and send it
        for key in r.keys('tx:*'):
            # format compact json msg
            k = key.decode('utf8')[3:]
            v = r.get(key).decode('utf8')
            tx_dict_as_json({'t': 'rkey', 'k': k, 'v': v})
            r.delete(key)
        # before next loop
        time.sleep(0.2)


# parse argument
parser = argparse.ArgumentParser(description='Redis bridge over serial link')
parser.add_argument('-n', '--name', type=str, default='rem',
                    help='Bridge name (default is rem)')
parser.add_argument('-d', '--device', type=str, default='/dev/ttyAMA0',
                    help='Serial device (default is /dev/ttyAMA0)')
parser.add_argument('-b', '--baud', type=int, default=115200,
                    help='Baud rate (default is 115200)')
parser.add_argument('--alive', type=float, default=5.0,
                    help='Alive interval in second (default is 5.0)')
parser.add_argument('--db', type=int, default=0,
                    help='Redis DB number to connect (default is 0)')
args = parser.parse_args()

# some var
r = redis.StrictRedis(db=args.db)
s = serial.Serial(args.device, baudrate=args.baud)

# init bridge status
r_name = 'brg:' + args.name + ':'
r.set(r_name + 'device', args.device)
r.set(r_name + 'redis_db', args.db)
r.set(r_name + 'tx_frame_counter', 0)
r.set(r_name + 'rx_frame_counter', 0)
r.set(r_name + 'rx_sum_error_counter', 0)
r.set(r_name + 'rx_format_error_counter', 0)

# start serial IO thread
threading.Thread(target=read_thread).start()
threading.Thread(target=write_thread).start()
